# Техническая Документация (v.Current)

> **Статус:** Активен / Стабилен
> **Последнее обновление:** 2026-01-16
> **Роль:** Единый Источник Истины (Single Source of Truth)

---

## 1. Высокоуровневая Архитектура

Проект представляет собой отказоустойчивый **Telegram-бот**, написанный на Python, разработанный для высокой доступности (24/7). Он работает как монолитное приложение с модульными сервисами, используя **Google Sheets** в качестве основной базы данных и **Google Gemini 3 Pro** для возможностей ИИ.

### Технологический Стек
*   **Язык:** Python 3.12+
*   **Фреймворк:** `python-telegram-bot` (v20+, Async)
*   **База Данных:** Google Sheets (через `gspread` + `tenacity` для повторных попыток)
*   **ИИ Движок:** Google Gemini 3 Pro (через `google-genai` SDK)
*   **Сетевая связность:** Работа через US-прокси (для обхода региональных ограничений)
*   **Развертывание:** Systemd Service (Linux/Ubuntu)

### Диаграмма Архитектуры (Логическая)

```mermaid
graph TD
    User((Пользователь)) <-->|Telegram API| Bot[Core Бота]
    User <-->|Mini App| WebApp[Web App / Фронтенд]
    
    subgraph "Основные Сервисы"
        Bot --> AuthService[Сервис Авторизации]
        Bot --> AppealsService[Сервис Обращений]
        Bot --> AIService[Унифицированный AIService]
        AIService <--> GeminiService[Gemini 3 Pro Service]
        Bot --> Notifier[Уведомления Акций]
    end
    
    subgraph "Слой Данных (Gateway)"
        AuthService --> Gateway[Async Google Sheets Gateway]
        AppealsService --> Gateway
        Notifier --> Gateway
        Gateway -->|Circuit Breaker + Retry| GSheets[(Google Sheets)]
    end
    
    subgraph "Внешние Интеграции"
        GeminiService <-->|US Proxy| Gemini[Google AI Platform]
    end
```

### Ключевые Архитектурные Решения
1.  **Паттерн Gateway:** Все взаимодействия с Google Sheets проходят через `AsyncGoogleSheetsGateway`. Этот слой управляет лимитами запросов, повторными попытками (экспоненциальная задержка) и стабильностью соединения.
2.  **Circuit Breaker (Предохранитель):** Реализован для предотвращения каскадных сбоев. Если Google Sheets перестает отвечать, бот временно ограничивает функционал, а не падает полностью.
3.  **Graceful Shutdown (Плавная остановка):** Бот обрабатывает сигналы `SIGINT`/`SIGTERM` для безопасного закрытия соединений и сохранения состояния перед выходом.
4.  **Отсутствие Локальной БД:** Система не хранит персистентные данные локально; все бизнес-данные находятся в Google Sheets. Состояние выполнения (например, ID тредов OpenAI) хранится в памяти.

---

## 2. Структура Данных

"База данных" подразумевает конкретную Google Таблицу с несколькими листами.

### 2.1 Лист Auth (Пользователи)
Хранит реестр пользователей и статус авторизации.

| Колонка | Имя (Заголовок) | Описание |
| :--- | :--- | :--- |
| **A** | *Код партнера* | Уникальный идентификатор партнера. (Используется для поиска) |
| **B** | *Телефон* | Номер телефона партнера. (Используется для поиска) |
| **C** | *ФИО* | Полное имя. |
| **D** | **STATUS** | Статус авторизации (`authorized` / `avtorizovan`). |
| **E** | **Telegram ID** | Привязанный ID пользователя Telegram. |
| **F** | **Updated At** | Временная метка последнего изменения авторизации. |

> **Примечание:** Авторизация ищет пользователя по совпадению `Код партнера` И `Телефон`. Если найдено, обновляются колонки D, E, F.

### 2.2 Лист Appeals (Обращения)
Хранит тикеты поддержки и историю чата.

| Колонка | Индекс | Заголовок | Описание |
| :--- | :--- | :--- | :--- |
| **A** | 0 | Code | Код партнера. |
| **B** | 1 | Phone | Телефон. |
| **C** | 2 | FIO | ФИО. |
| **D** | 3 | Telegram ID | ID пользователя Telegram. |
| **E** | 4 | **Text** | **Накопленная История**. Содержит весь лог чата для активного тикета. |
| **F** | 5 | **Status** | Статус тикета (см. ниже). |
| **G** | 6 | Specialist Answer| Черновик ответа от специалиста (для отправки ботом). |
| **H** | 7 | Updated At | Временная метка последнего изменения. |

#### Жизненный цикл Статуса (Колонка F)
*   `Новое` (Цвет: #f3cccc) — Создано пользователем, ждет ИИ или Человека.
*   `Ответ ИИ` (Цвет: #ffffff) — ИИ ответил.
*   `В работе` (Цвет: #fff2cc) — Взято в работу специалистом (или запрошен "Человек").
*   `Передано специалисту` (Цвет: #f3cccc) — Явная эскалация.
*   `Решено` (Цвет: #d9ead3) — Тикет закрыт.

---

## 3. Бизнес-Логика и Алгоритмы

### 3.1 Флоу Авторизации
1.  Пользователь запускает бота через `/start`.
2.  **Проверка:** `AuthService` проверяет `TTLCache` (в памяти) или запрашивает Лист Auth по `Telegram ID`.
3.  **Если Неизвестен:** Бот запрашивает Авторизацию через Web App (Mini App).
4.  **Web App:** Пользователь вводит `Код` и `Телефон`.
5.  **Валидация:** Бот нормализует телефон (например, `8999...`), ищет в Листе Auth.
6.  **Успех:** Если совпадение найдено -> Обновить Лист (Кол D, E, F) -> Обновить Кэш -> Показать Меню.
7.  **Ошибка:** Показать ошибку и кнопку повтора.

### 3.2 Чат и Флоу ИИ (Гибридный)
1.  **Ввод:** Пользователь отправляет текстовое сообщение.
2.  **Фильтр:** Это ключевое слово эскалации (например, "позови человека")?
    *   *Да:* Остановить ИИ, установить Статус `Передано специалисту`, показать кнопку "Связаться со специалистом".
3.  **Проверка Статуса:** Текущий статус тикета `В работе`?
    *   *Да:* ИИ молчит. Логировать сообщение в Лист (Кол E). Ждать ответа человека.
4.  **Выполнение ИИ:**
    *   Отправить текст в **OpenAI Assistant** (Тред живет в памяти).
    *   Получить ответ.
    *   **Пост-процессинг:** Проверить, не предлагает ли ИИ эскалацию ("Вас соединить?").
    *   **Отправка:** Ответ пользователю + Лог в Лист (Кол E) + Установить Статус `Ответ ИИ`.

### 3.3 Ответ Специалиста (Обратный Флоу)
1.  **Мониторинг:** `ResponseMonitor` опрашивает Лист Appeals (Кол G) каждые 60 сек.
2.  **Триггер:** Специалист пишет текст в Колонку G.
3.  **Действие:**
    *   Бот отправляет текст Пользователю по `telegram_id` (из Кол D).
    *   Бот очищает Колонку G.
    *   Бот добавляет текст в Историю (Кол E).

---

## 4. Интеграции и API

### 4.1 Внутренние Сервисы
*   **Google Sheets API:** Аутентификация через JSON Сервисного Аккаунта (`GCP_SA_FILE`).
*   **OpenAI API:** Использует `OPENAI_API_KEY`.
    *   **Поддержка Прокси:** Настраивается через `OPENAI_PROXY` (важно для серверов с ограниченным доступом, как Яндекс Облако).
    *   **Модель:** Определяется через `OPENAI_ASSISTANT_ID` (пресет Ассистента).

### 4.2 Вебхуки и Mini App
*   **Эндпоинт:** `/webhook/promotions` (Flask/Werkzeug).
*   **Цель:** Принимает POST запросы (например, от триггеров Google Apps Script) для рассылки акций.
*   **Mini App:** Статические HTML/JS файлы (`index.html`, `menu.html`), загружаемые внутри Telegram WebObject.

### 4.3 История Разработки
*   Полная история технических решений, новых функций и версий отслеживается в [CHANGELOG.md](CHANGELOG.md).
*   Смотрите **CHANGELOG**, чтобы увидеть эволюцию от начального прототипа до текущей микро-сервисной архитектуры.

---

## 5. Руководство по Развертыванию и Разработке

### 5.1 Структура Проекта (Карта Файлов)
Для начинающего разработчика, вот за что отвечает каждый файл:
*   `bot.py`: **Двигатель**. Запускает бота, соединяет сервисы, обрабатывает ошибки. Начинайте отсюда.
*   `handlers.py`: **Мозг**. Содержит логику для `/start`, сообщений чата и кнопок. Редактируйте здесь, чтобы изменить *что* говорит бот.
*   `auth_service.py`: **Охрана**. Проверяет права пользователя в Google Sheets.
*   `appeals_service.py`: **Система Тикетов**. Логика создания/обновления тикетов в Таблицах.
*   `sheets_gateway.py`: **Драйвер Базы**. Низкоуровневый коннектор к Google Sheets с защитой от сбоев.
*   `openai_service.py`: **Коннектор ИИ**. Отправляет сообщения Ассистенту OpenAI.

### 5.2 Настройка Локального Окружения (Пошагово)
1.  **Установите Python 3.10+**.
2.  **Клонируйте проект** на свой компьютер.
3.  **Создайте Виртуальное Окружение** (Изолированная песочница):
    ```bash
    python3 -m venv .venv
    source .venv/bin/activate  # На Windows: .venv\Scripts\activate
    ```
4.  **Установите Зависимости**:
    ```bash
    pip install -r requirements.txt
    ```
5.  **Настройте Секреты**:
    *   Скопируйте `.env.example` в `.env`.
    *   Заполните `TELEGRAM_TOKEN`, `SHEET_ID` и т.д.
    *   **Важно:** Если запускаете в Яндекс Облаке, установите `OPENAI_PROXY`.
    *   Убедитесь, что `credentials.json` (Google Service Account) лежит в папке проекта.
6.  **Запустите Бота**:
    ```bash
    python bot.py
    ```
    *Если успешно, вы увидите "Запуск бота..." в консоли.*

### 5.3 Типовые Сценарии Изменений

#### Сценарий А: Изменить Приветственное Сообщение
1.  Откройте `handlers.py`.
2.  Найдите `start_command_handler`.
3.  Отредактируйте текст внутри `await update.message.reply_text("...")`.
4.  Перезапустите бота (`Ctrl+C`, затем `python bot.py`), чтобы увидеть изменения.

#### Сценарий Б: Добавить Новую Команду (например, /help)
1.  Откройте `handlers.py`.
2.  Создайте функцию `async def help_command(update, context): ...`.
3.  Перейдите к функции `setup_handlers` в `handlers.py`.
4.  Добавьте `application.add_handler(CommandHandler("help", help_command))`.

#### Сценарий В: Дебаг "Почему бот упал?"
1.  Проверьте файл `bot.log`.
2.  Ищите строки с "CRITICAL" или "ERROR".
3.  Если ошибка связана с Google Sheets, проверьте логи `sheets_gateway.py`.

---

## 6. Продакшн Развертывание (Сервер)

Бот работает на **Виртуальной Машине Яндекс Облака** (Ubuntu/Linux), используя **Systemd** как менеджер сервисов.

### Полезные Команды
*   **Проверить Статус:** `sudo systemctl status marketingbot`
    *   *Зеленый (active)* = Хорошо.
    *   *Красный (failed)* = Упал. Читайте логи.
*   **Перезапустить Бот:** `sudo systemctl restart marketingbot`
    *   Запускайте это после *каждого* обновления кода на сервере.
*   **Смотреть Логи в Реал-тайме:** `journalctl -u marketingbot -f`
