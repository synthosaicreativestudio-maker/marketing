# Технический Архив: Система памяти на базе SQLite

> **Статус:** ДЕПРЕКАЦИЯ / АРХИВ (Февраль 2026)
> **Заменено на:** Google Sheets (Прямое чтение истории диалогов)

## Обзор
Изначально в MarketingBot планировалось использовать локальную базу данных SQLite для хранения кратковременной памяти диалогов (контекста) и кеширования авторизации. Это должно было снизить нагрузку на Google Sheets API и ускорить работу бота.

## Архитектура
Для реализации использовался стек:
- **aiosqlite:** Асинхронная обертка над SQLite.
- **SQLiteMemoryManager:** Класс-обертка для управления сессиями и историей.
- **Модели:** `UserHistory`, `AuthCache`.

### Основные компоненты (в архиве кода):
- `marketingbot/memory_manager_sqlite.py` — менеджер БД.
- `db/database.py`, `db/models.py` — описание схемы.

## Причины отказа
1.  **Конфликты распределенного окружения:** Бот работает на сервере, но данные SQLite хранились локально в файле. При пересборках или работе нескольких инстансов возникали рассинхроны.
2.  **Дублирование данных:** История диалогов уже хранилась в Google Sheets для администраторов. Использование SQLite требовало сложной логики синхронизации.
3.  **Упрощение поддержки:** Переход на прямое чтение истории из Google Sheets (через `AppealsService.get_raw_history`) позволил сделать бота «бесстейтовым» (stateless) по отношению к локальной ФС.
4.  **Стабильность:** Устранение зависимости `aiosqlite` снизило вероятность ошибок при асинхронном доступе к файлу БД.

## Как это работало (Legacy Flow)
```python
# Старая логика получения истории
history = await self.sqlite_memory.get_history(user_id)
if not history:
    history = await appeals_service.get_raw_history(user_id) # Fallback
```

*Документ подготовлен для сохранения технической истории проекта.*
