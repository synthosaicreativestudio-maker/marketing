# ТЕХНИЧЕСКОЕ ЗАДАНИЕ: УНИВЕРСАЛЬНЫЙ АНАЛИЗАТОР НЕДВИЖИМОСТИ

## ЦЕЛЬ ПРОЕКТА

Создать универсальный инструмент анализа недвижимости, позволяющий любому риэлтору в компании анализировать свой объект по коду через чат-бот.

## ТЕКУЩЕЕ СОСТОЯНИЕ

- ✅ Работающая система анализа для группы объектов
- ✅ Все расчетные алгоритмы готовы
- ✅ Интеграция с Gemini AI
- ❌ Негибкая архитектура (только для группы)
- ❌ Нет интеграции с чат-ботом
- ❌ Ручной ввод данных

## ЦЕЛЕВОЕ СОСТОЯНИЕ

- ✅ Универсальный анализ любого объекта по коду
- ✅ Интеграция с чат-ботом
- ✅ Автоматический поиск объекта в базе
- ✅ Онлайн-анализ в реальном времени
- ✅ Масштабируемая архитектура

## АРХИТЕКТУРА РЕШЕНИЯ

### ПОТОК ДАННЫХ
```
Чат-бот → Код объекта → Google Таблицы → Apps Script → Анализ → Отчет → Чат-бот
```

### НОВЫЕ КОМПОНЕНТЫ

#### 1. НОВЫЕ ЛИСТЫ
- `аналитика ОН по коду` - входная точка (переименовать из "аналитика ОН по адресу/коду")
- `аналитика ОН по адресу` - для будущего функционала
- `лист анализа объекта` - аналог "аналитика всех ОН в группе" для одного объекта
- `конкуренты активные и проданные для анализа` - массив конкурентов для одного объекта

#### 2. НОВЫЕ ФУНКЦИИ
```javascript
// Поиск и валидация
findObjectByCode(code)              // Поиск объекта по коду
validateCode(code)                  // Валидация кода

// Анализ одного объекта  
analyzeSingleObject(objectData)     // Анализ одного объекта
filterCompetitorsForSingleObject()  // Фильтрация конкурентов

// Генерация отчетов
generateSingleObjectReport()        // Генерация отчета
formatSingleObjectData()            // Форматирование данных

// Интеграция с чат-ботом
processBotRequest()                 // Обработка запроса от бота
setupWebhook()                      // Настройка webhook
```

## ДЕТАЛЬНАЯ СПЕЦИФИКАЦИЯ

### 1. ПОИСК ОБЪЕКТА ПО КОДУ

#### Функция: `findObjectByCode(code)`
```javascript
function findObjectByCode(code) {
  // 1. Очистка и валидация кода
  const cleanCode = String(code).trim().toLowerCase();
  
  // 2. Поиск в листе "2. 2. активные"
  const activeSheet = SPREADSHEET.getSheetByName('2. 2. активные');
  const activeData = activeSheet.getRange('A2:M' + activeSheet.getLastRow()).getValues();
  
  // 3. Поиск по коду (предполагаем столбец F - код)
  const foundRow = activeData.find(row => 
    String(row[5]).trim().toLowerCase() === cleanCode
  );
  
  // 4. Возврат данных или null
  return foundRow || null;
}
```

#### Структура данных объекта (из "2. 2. активные")
```
A: Дата вывода заявки
B: Район
C: Тип объекта  
D: Кол-во комнат
E: Площадь
F: Код объекта
G: Тип ремонта
H: Цена
I: Этаж
J: Этажность
K: Год постройки
L: Ссылка
M: Состояние дома
```

### 2. АНАЛИЗ ОДНОГО ОБЪЕКТА

#### Функция: `analyzeSingleObject(objectData)`
```javascript
function analyzeSingleObject(objectData) {
  // 1. Извлечение характеристик объекта
  const district = objectData[1];
  const type = objectData[2];
  const rooms = Number(objectData[3]);
  const area = Number(objectData[4]);
  const code = String(objectData[5]);
  const price = Number(objectData[7]);
  const repair = objectData[6];
  const buildYear = Number(objectData[10]);
  
  // 2. Поиск конкурентов
  const competitors = findCompetitorsForSingleObject({
    district, type, rooms, area, repair, buildYear
  });
  
  // 3. Расчет метрик (используем существующие функции)
  const metrics = calculateObjectMetrics({...});
  const priceFork = calculatePriceFork({...});
  const timeOnMarket = calculateTimeOnMarket({...});
  
  // 4. Возврат результатов
  return {
    objectData,
    competitors,
    metrics,
    priceFork,
    timeOnMarket
  };
}
```

### 3. ФИЛЬТРАЦИЯ КОНКУРЕНТОВ

#### Функция: `filterCompetitorsForSingleObject(params)`
```javascript
function filterCompetitorsForSingleObject(params) {
  const { district, type, rooms, area, repair, buildYear } = params;
  
  // 1. Получение данных конкурентов
  const activeData = getActiveCompetitorsData();
  const soldData = getSoldCompetitorsData();
  
  // 2. Фильтрация по критериям (используем существующую логику)
  const activeFiltered = filterByCriteria(activeData, params);
  const soldFiltered = filterByCriteria(soldData, params);
  
  // 3. Форматирование результатов
  const activeCompetitors = activeFiltered.map(row => formatCompetitorRow(row, false));
  const soldCompetitors = soldFiltered.map(row => formatCompetitorRow(row, true));
  
  return { activeCompetitors, soldCompetitors };
}
```

### 4. ИНТЕГРАЦИЯ С ЧАТ-БОТОМ

#### Webhook для чат-бота
```javascript
function doPost(e) {
  try {
    // 1. Получение данных от чат-бота
    const data = JSON.parse(e.postData.contents);
    const code = data.code;
    
    // 2. Валидация кода
    if (!validateCode(code)) {
      return ContentService.createTextOutput(JSON.stringify({
        success: false,
        error: 'Неверный формат кода'
      }));
    }
    
    // 3. Поиск объекта
    const objectData = findObjectByCode(code);
    if (!objectData) {
      return ContentService.createTextOutput(JSON.stringify({
        success: false,
        error: 'Объект не найден'
      }));
    }
    
    // 4. Анализ объекта
    const analysis = analyzeSingleObject(objectData);
    
    // 5. Генерация отчета
    const report = generateSingleObjectReport(analysis);
    
    // 6. Возврат результата
    return ContentService.createTextOutput(JSON.stringify({
      success: true,
      data: report
    }));
    
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    }));
  }
}
```

## ПЛАН РЕАЛИЗАЦИИ

### ЭТАП 1: ПОДГОТОВКА (1-2 дня)
- [ ] Создать новые листы в Google Таблице
- [ ] Настроить структуру заголовков
- [ ] Протестировать доступ к данным

### ЭТАП 2: БАЗОВАЯ ФУНКЦИОНАЛЬНОСТЬ (3-4 дня)
- [ ] Реализовать `findObjectByCode()`
- [ ] Реализовать `analyzeSingleObject()`
- [ ] Адаптировать фильтрацию конкурентов
- [ ] Протестировать на реальных данных

### ЭТАП 3: СИСТЕМА ОТЧЕТОВ (2-3 дня)
- [ ] Реализовать `generateSingleObjectReport()`
- [ ] Адаптировать форматирование данных
- [ ] Интегрировать с Gemini AI
- [ ] Протестировать генерацию отчетов

### ЭТАП 4: ИНТЕГРАЦИЯ С ЧАТ-БОТОМ (2-3 дня)
- [ ] Настроить webhook в Google Apps Script
- [ ] Реализовать `doPost()` функцию
- [ ] Интегрировать с чат-ботом
- [ ] Протестировать полный цикл

### ЭТАП 5: ТЕСТИРОВАНИЕ И ОПТИМИЗАЦИЯ (1-2 дня)
- [ ] Комплексное тестирование
- [ ] Оптимизация производительности
- [ ] Обработка ошибок
- [ ] Документация

## ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ

### ПРОИЗВОДИТЕЛЬНОСТЬ
- Время анализа одного объекта: < 30 секунд
- Максимальное время ответа webhook: < 10 секунд
- Поддержка до 100 запросов в час

### НАДЕЖНОСТЬ
- Обработка всех возможных ошибок
- Graceful degradation при недоступности данных
- Логирование всех операций

### БЕЗОПАСНОСТЬ
- Валидация всех входных данных
- Ограничение доступа к webhook
- Защита от SQL-инъекций (если применимо)

## КРИТЕРИИ ПРИЕМКИ

### ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ
- [ ] Поиск объекта по коду работает корректно
- [ ] Анализ конкурентов соответствует существующей логике
- [ ] Генерация отчета идентична текущей системе
- [ ] Интеграция с чат-ботом функционирует

### НЕФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ
- [ ] Производительность соответствует требованиям
- [ ] Система устойчива к ошибкам
- [ ] Код соответствует стандартам качества
- [ ] Документация полная и актуальная

## РИСКИ И МИТИГАЦИЯ

### ВЫСОКИЙ РИСК
- **Несовместимость структур данных** - детальное изучение листов перед началом
- **Производительность при росте базы** - оптимизация алгоритмов

### СРЕДНИЙ РИСК  
- **Ошибки в интеграции с чат-ботом** - тщательное тестирование
- **Изменения в API Gemini** - мониторинг и адаптация

### НИЗКИЙ РИСК
- **Ошибки в расчетных функциях** - функции уже протестированы
- **Проблемы с форматированием** - адаптация существующего кода

---

*Техническое задание версии 1.0*
